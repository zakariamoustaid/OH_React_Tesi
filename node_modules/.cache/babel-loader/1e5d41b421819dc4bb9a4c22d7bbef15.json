{"ast":null,"code":"import moment from \"moment\";\nconst formats = [\"DD/MM/YYYY\", \"YYYY-MM-DD\", \"YYYY-MM-DD HH:mm:ss\", \"DD/MM/YYYY HH:mm:ss\"];\nexport function dateComparator(order, key) {\n  let reverse = order === \"desc\" ? 1 : -1;\n  return (a, b) => {\n    if (moment(b[key], formats).isAfter(moment(a[key], formats))) {\n      return 1 * reverse;\n    }\n\n    if (moment(b[key], formats).isBefore(moment(a[key], formats))) {\n      return -1 * reverse;\n    }\n\n    return 0;\n  };\n}\nexport function defaultComparator(order, key) {\n  let reverse = order === \"desc\" ? 1 : -1;\n  return (a, b) => {\n    if (a[key] < b[key]) return 1 * reverse;\n    if (a[key] > b[key]) return -1 * reverse;\n    return 0;\n  };\n}","map":{"version":3,"sources":["/home/zak/Tesi/OH_React_Tesi/src/libraries/sortUtils/sortUtils.ts"],"names":["moment","formats","dateComparator","order","key","reverse","a","b","isAfter","isBefore","defaultComparator"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,QAAnB;AAGA,MAAMC,OAAO,GAAG,CACd,YADc,EAEd,YAFc,EAGd,qBAHc,EAId,qBAJc,CAAhB;AAMA,OAAO,SAASC,cAAT,CAA+CC,KAA/C,EAA8DC,GAA9D,EAAwE;AAC7E,MAAIC,OAAO,GAAGF,KAAK,KAAK,MAAV,GAAmB,CAAnB,GAAuB,CAAC,CAAtC;AACA,SAAO,CAACG,CAAD,EAASC,CAAT,KAAoB;AACzB,QAAIP,MAAM,CAACO,CAAC,CAACH,GAAD,CAAF,EAASH,OAAT,CAAN,CAAwBO,OAAxB,CAAgCR,MAAM,CAACM,CAAC,CAACF,GAAD,CAAF,EAASH,OAAT,CAAtC,CAAJ,EAA8D;AAC5D,aAAO,IAAII,OAAX;AACD;;AACD,QAAIL,MAAM,CAACO,CAAC,CAACH,GAAD,CAAF,EAASH,OAAT,CAAN,CAAwBQ,QAAxB,CAAiCT,MAAM,CAACM,CAAC,CAACF,GAAD,CAAF,EAASH,OAAT,CAAvC,CAAJ,EAA+D;AAC7D,aAAO,CAAC,CAAD,GAAKI,OAAZ;AACD;;AACD,WAAO,CAAP;AACD,GARD;AASD;AAED,OAAO,SAASK,iBAAT,CACLP,KADK,EAELC,GAFK,EAGL;AACA,MAAIC,OAAO,GAAGF,KAAK,KAAK,MAAV,GAAmB,CAAnB,GAAuB,CAAC,CAAtC;AACA,SAAO,CAACG,CAAD,EAASC,CAAT,KAAoB;AACzB,QAAID,CAAC,CAACF,GAAD,CAAD,GAASG,CAAC,CAACH,GAAD,CAAd,EAAqB,OAAO,IAAIC,OAAX;AACrB,QAAIC,CAAC,CAACF,GAAD,CAAD,GAASG,CAAC,CAACH,GAAD,CAAd,EAAqB,OAAO,CAAC,CAAD,GAAKC,OAAZ;AACrB,WAAO,CAAP;AACD,GAJD;AAKD","sourcesContent":["import moment from \"moment\";\nimport { TOrder } from \"./types\";\n\nconst formats = [\n  \"DD/MM/YYYY\",\n  \"YYYY-MM-DD\",\n  \"YYYY-MM-DD HH:mm:ss\",\n  \"DD/MM/YYYY HH:mm:ss\",\n];\nexport function dateComparator<Key extends keyof any>(order: TOrder, key: Key) {\n  let reverse = order === \"desc\" ? 1 : -1;\n  return (a: any, b: any) => {\n    if (moment(b[key], formats).isAfter(moment(a[key], formats))) {\n      return 1 * reverse;\n    }\n    if (moment(b[key], formats).isBefore(moment(a[key], formats))) {\n      return -1 * reverse;\n    }\n    return 0;\n  };\n}\n\nexport function defaultComparator<Key extends keyof any>(\n  order: TOrder,\n  key: Key\n) {\n  let reverse = order === \"desc\" ? 1 : -1;\n  return (a: any, b: any) => {\n    if (a[key] < b[key]) return 1 * reverse;\n    if (a[key] > b[key]) return -1 * reverse;\n    return 0;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}